/*
 *  VoodooIntel3945.h
 *  VoodooIntel3945
 *
 *  Created by Prashant Vaibhav on 31/08/09.
 *  Copyright 2009 Prashant Vaibhav. All rights reserved.
 *
 */

#ifndef _VOODOOINTEL3945_H
#define _VOODOOINTEL3945_H

#pragma mark Includes
#include <sys/types.h>
#include <sys/kernel_types.h>

#include <IOKit/IOLib.h>
#include <IOKit/IOBufferMemoryDescriptor.h>
#include <IOKit/IOInterruptEventSource.h>
#include <IOKit/IOTimerEventSource.h>
#include <IOKit/IOWorkLoop.h>
#include <IOKit/network/IOMbufMemoryCursor.h>
#include <IOKit/pci/IOPCIDevice.h>

#include <VoodooWireless/VoodooWirelessDevice.h>
#include "if_wpireg.h"
#include "ieee80211_amrr.h"

#define super		VoodooWirelessDevice
#define MyClass		VoodooIntel3945

/* The following is used for the auth/assoc process. TODO: Move to VoodooWireless */
struct AuthenticationFrame {
	IEEE::ManagementFrameHeader hdr;
	uint16_t	algorithm; // = 0 for open, 1 for shared
	uint16_t	sequence;  // = 1 for request, 2 for response
	uint16_t	status;	// refer to table 7-23 in spec
} __packed;

struct AssocRequestFrame {
	IEEE::ManagementFrameHeader hdr;
	IEEE::Capability	cap;
	uint16_t		lintval;
	/* followed by 3 IEs in this order:
	 SSID
	 supported rates
	 extended supported rates
	 */
	uint8_t			ie[2+32+2+8+2+4+50];
} __packed;

struct AssocResponseFrame {
	IEEE::ManagementFrameHeader hdr;
	IEEE::Capability	cap;
	uint16_t		status;
	uint16_t		aid; // association ID
	/* followed by IEs :
	 supported rates
	 extended supported rates
	 edca parameter set
	 */
} __packed;

class VoodooIntel3945: public VoodooWirelessDevice
{
	/* This is required for I/OKit to properly recognize our class for the RTTI system */
	OSDeclareDefaultStructors(VoodooIntel3945)
	
private:
#pragma mark Private variables
	/* Hardware related data */
	IOPCIDevice*			m_PciDevice;	/* The PCI nub we'll use to access the HW */
	IOMemoryMap*			m_DeviceMap;	/* Device memory map */
	uint8_t*			m_Registers;	/* Pointer to memory mapped CSR region */
	
	/* DMA buffers */
	IOBufferMemoryDescriptor*	m_Firmware;	/* Buffer to store firmware images while loading */
	IOBufferMemoryDescriptor*	m_SharedPage;	/* Page of memory shared between NIC and host PC */
	wpi_shared*			m_SharedPagePtr;
	IOBufferMemoryDescriptor*	m_RxRingMemory;	/* DMA safe memory for storing pointers to Rx mbufs */
	
	/* Ring structures */
	struct TxRing {
		IOBufferMemoryDescriptor* descMemory;	/* Store the descriptors for each command or tx mbuf */
		IOBufferMemoryDescriptor* cmdMemory;	/* Slots for holding cmd data */
		wpi_tx_desc*	descriptors;		/* VM pointer to desc array */
		wpi_tx_cmd*	cmdSlots;		/* VM pointer to cmd data array */
		uint32_t	cmdPhysAdd;		/* Physical address of start of cmd data array */
		mbuf_t		mbufs[WPI_TX_RING_COUNT];/* Array of commands mapped into mbufs (if any) */
		int	qid;				/* Queue ID (0-3 for WME) */
		int	count;				/* How many items this queue holds */
		int	queued;				/* How many are queued */
		int	current;			/* Current queue item */
	};
	TxRing				m_TxRing[4];
	TxRing				m_CmdRing;
	
	struct RxRing {
		int		current;
		mbuf_t		mbufs[WPI_RX_RING_COUNT];/* Incoming packets get stored here */
		uint32_t*	rx_pkt_ptr;		/* Pointer to list of paddr pointers-to-mbuf */
		uint32_t	physAdd;		/* Aligned physical address */
	};
	RxRing				m_RxRing;
	
	/* Other assets */
	IO80211WorkLoop*		m_WorkLoop;	/* Workloop for single-threaded HW access */
	IOInterruptEventSource*		m_InterruptSrc;	/* Interrupt generated by the HW */
	IOTimerEventSource*		m_Timer;	/* for various duties */
	int				m_PowerCountdown; /* count seconds until power recalibration */
	IOMbufLittleMemoryCursor*	m_MbufCursor;	/* For getting scatter gather list */
	bool				m_SupportsA;	/* where 802.11a is supported by this SKU */
	bool				m_FirmwareLoaded;/* Wait event for firmware load */
	bool				m_CommandDone;	/* Wait event for adapter command */
	uint32_t			m_Flags;	/* Misc. driver flag bits */
	int				m_Temperature;	/* HW temperature */
	uint64_t			m_Timestamp;	/* Received from last beacon */
	uint16_t			m_BeaconInterval;	/*   "   */
	wpi_config			m_Config;	/* HW configuration */
	IEEE::MACAddress		m_MacAddress;	/* Our hw address */
	IEEE::Channel			m_CurrentChannel;
	int				m_AssocID;	/* Current association ID */
	AssociationParameters		m_AssocParams;	/* For use during auth/assoc */
	enum AssocState {
		staInit, staAuthTry, staAssocTry, staAssociated
	};
	AssocState			m_AssocState;	/* For keeping track of the current stage in auth/assoc */
	int				m_TxRateIndex;	/* Which rate to transmit at, from m_AssocParams.supportedRates */
	struct ieee80211_amrr_node	amrrNode;	/* For automatic rate adaptation */
	struct ieee80211_amrr		amrr;
	
	/* EEPROM info */
	uint8_t				m_HWCap;
	uint16_t			m_HWRev;
	uint8_t				m_HWType;
	wpi_power_group			m_PowerGroups[5];
	int8_t				m_MaxPower[255];
	
	
protected:	
#pragma mark Hardware specific functions
	IOReturn	allocateResources	( IOService* provider );
	IOReturn	turnPowerOn		( );
	IOReturn	turnPowerOff		( );
	void		freeResources		( IOService* provider );
	IOReturn	startScan		( const ScanParameters* params, const IEEE::ChannelList* channels );
	void		abortScan		( );
	IOReturn	associate		( const AssociationParameters* params );
	IOReturn	disassociate		( );
	void		getHardwareInfo		( HardwareInfo* info );
	IOReturn	getConfiguration	( HardwareConfigType type, void* param );
	IOReturn	setConfiguration	( HardwareConfigType type, void* param );
	IOReturn	outputFrame		( TxFrameHeader hdr, mbuf_t data );
	
	void		interruptOccurred	( OSObject* owner, IOInterruptEventSource* intr, int count );
	void		timerOccurred		( OSObject* owner, IOTimerEventSource* timer );
	
private:
	IOReturn	uploadFirmware		( );
	IOReturn	uploadMicrocode		( const uint8_t* data, size_t len );
	IOReturn	resetAdapter		( );
	IOReturn	powerUp			( );
	IOReturn	stopMaster		( );
	IOReturn	configure		( );
	void		configureHardware	( );
	IOReturn	sendCommand		( int code, const void* buf, int size, bool async = true );
	IOReturn	setTxPower		( IEEE::Channel chan, bool async = true );
	int		getPowerIndex		( wpi_power_group* group, IEEE::Channel c, int rate);
	IOReturn	mrrSetup		( );
	uint8_t		plcpSignal		( int rate );
	void		resetTxRing		( TxRing* ring );
	void		resetRxRing		( RxRing* ring );
	IOReturn	sendManagementFrame	( const uint8_t* data, const size_t len );
	void		sendAssocRequest	( );
	void		postAssocProcedure	( int assocID );
	
	void		setLED			( uint8_t which, uint8_t off, uint8_t on );
	
	void		notificationInterrupt	( );
	void		rxInterrupt		( wpi_rx_desc* desc );
	void		txInterrupt		( wpi_rx_desc* desc );
	void		cmdInterrupt		( wpi_rx_desc* desc );
	
	void		memLock			( );
	void		memUnlock		( );
	uint32_t	memRead			( uint32_t offset );
	void		memWrite		( uint32_t offset, uint32_t data );
	void		memWriteRegion		( uint32_t offset, const uint32_t* data, int ndwords );
	IOReturn	readPromData		( uint32_t addr, void *data, int len );
	IOBufferMemoryDescriptor* allocDmaMemory( size_t size, int alignment, void** vaddr, uint32_t* paddr );
};

#endif//_VOODOOINTEL3945_H